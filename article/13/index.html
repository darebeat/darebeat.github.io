<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="clickhouse基础知识, darebeat"><meta name="description" content="不恋过去，不畏将来，活在当下，行所当行，阻挡你前进的最大阻力永远是你自己！"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>clickhouse基础知识 | darebeat</title><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.min.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><script src="/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 6.3.0"><style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style><link rel="alternate" href="/atom.xml" title="darebeat" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"> <a href="/" class="waves-effect waves-light"><img src="/medias/logo.png" class="logo-img" alt="LOGO"> <span class="logo-span">darebeat</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom: 0.6;"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fas fa-tags" style="zoom: 0.6;"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fas fa-bookmark" style="zoom: 0.6;"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom: 0.6;"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom: 0.6;"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fas fa-address-book" style="zoom: 0.6;"></i> <span>友情链接</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"> <img src="/medias/logo.png" class="logo-img circle responsive-img" alt="LOGO"><div class="logo-name">darebeat</div><div class="logo-desc"> 不恋过去，不畏将来，活在当下，行所当行，阻挡你前进的最大阻力永远是你自己！</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa-fw fas fa-address-book"></i> 友情链接</a></li><li><div class="divider"></div></li><li><a href="https://github.com/darebeat" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i> Fork Me</a></li></ul></div></div><style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style> <a href="https://github.com/darebeat" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image: url('/images/card/0013.jpg')"><div class="container" style="right: 0px;left: 0px;"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">clickhouse基础知识</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.min.css"><style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"> <a href="/tags/database/"><span class="chip bg-color">database</span></a> <a href="/tags/clickhouse/"><span class="chip bg-color">clickhouse</span></a> <a href="/tags/olap/"><span class="chip bg-color">olap</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/database/" class="post-category">database</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i> 发布日期:&nbsp;&nbsp; 2020-12-03</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i> 文章字数:&nbsp;&nbsp; 6.2k</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="far fa-eye fa-fw"></i> 阅读次数:&nbsp;&nbsp;<span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><link rel="stylesheet" href="/libs/prism/prism.min.css"><div class="card-content article-card-content"><div id="articleContent"><p>博客从简书迁移: <a href="https://www.jianshu.com/p/a5bf490247ea" target="_blank">https://www.jianshu.com/p/a5bf490247ea</a></p><h2 id="clickhouse-简介">Clickhouse 简介</h2><blockquote><p>Clickhouse是一个用于联机分析处理（OLAP）的列式数据库管理系统（columnar DBMS）。<br> 传统数据库在数据大小比较小,索引大小适合内存,数据缓存命中率足够高的情形下能正常提供服务。<br> 但残酷的是,这种理想情形最终会随着业务的增长走到尽头,查询会变得越来越慢。<br> 你可能通过增加更多的内存,订购更快的磁盘等等来解决问题（纵向扩展）,但这只是拖延解决本质问题。<br> 如果你的需求是解决怎样快速查询出结果,那么ClickHouse也许可以解决你的问题。</p></blockquote><h3 id="应用场景">应用场景：</h3><ul><li><code>1.</code>绝大多数请求都是用于读访问的</li><li><code>2.</code>数据需要以大批次（大于1000行）进行更新,而不是单行更新；或者根本没有更新操作</li><li><code>3.</code>数据只是添加到数据库,没有必要修改</li><li><code>4.</code>读取数据时,会从数据库中提取出大量的行,但只用到一小部分列</li><li><code>5.</code>表很”宽”,即表中包含大量的列</li><li><code>6.</code>查询频率相对较低（通常每台服务器每秒查询数百次或更少）</li><li><code>7.</code>对于简单查询,允许大约50毫秒的延迟</li><li><code>8.</code>列的值是比较小的数值和短字符串（例如,每个URL只有60个字节）</li><li><code>9.</code>在处理单个查询时需要高吞吐量（每台服务器每秒高达数十亿行）</li><li><code>10.</code>不需要事务</li><li><code>11.</code>数据一致性要求较低</li><li><code>12.</code>每次查询中只会查询一个大表。除了一个大表,其余都是小表</li><li><code>13.</code>查询结果显著小于数据源。即数据有过滤或聚合。返回结果不超过单个服务器内存大小</li></ul><blockquote><p>相应地,使用ClickHouse也有其本身的限制：</p></blockquote><ul><li><code>1.</code>不支持真正的删除/更新支持 不支持事务（期待后续版本支持）</li><li><code>2.</code>不支持二级索引</li><li><code>3.</code>有限的SQL支持,join实现与众不同</li><li><code>4.</code>不支持窗口功能</li><li><code>5.</code>元数据管理需要人工干预维护</li></ul><h2 id="clickhouse为什么这么快">Clickhouse为什么这么快？</h2><ul><li>1.列式存储与数据压缩</li></ul><p>列式存储和数据压缩，对于一款高性能数据库来说是必不可少的。如果你想让查询变得更快，那么最简单且有效的方法是减少数据扫描范围和数据传输时的大小，列式存储和数据压缩就可以做到这两点。</p><ul><li>2.向量化执行</li></ul><div> <img src="/images/article/0013-001.png" style="width:100%;"></div><p><br></p><p>向量化执行，可以简单地看作一项消除程序中循环的优化，是基于底层硬件实现的优化。 将多次for循环计算变成一次计算完全仰仗于CPU的SIMD指令集，SIMD指令可以在一条cpu指令上处理2、4、8或者更多份的数据。 在Intel处理器上，这个称之为SSE以及后来的AVX；在ARM处理器上，这个称之为NEON。 简单来说，向量化计算就是将一个loop——处理一个array的时候每次处理1个数据共处理N次，转化为vectorization——处理一个array的时候每次同时处理8个数据共处理N/4次，假如cpu指令上可以处理更多份的数据，设为M，那就是N/M次。</p><p>为了实现向量化执行，需要利用CPU的SIMD指令。SIMD的全称是Single Instruction Multiple Data，即用单条指令操作多条数据。现代计算机系统概念中，它是通过数据并行以提高性能的一种实现方式，它的原理是在CPU寄存器层面实现数据的并行操作。ClickHouse目前利用SSE4.2指令集实现向量化执行。</p><ul><li>3.多样化的表引擎</li></ul><p>与MySQL类似，ClickHouse也将存储部分进行了抽象，把存储引擎作为一层独立的接口。目前ClickHouse共拥有合并树、内存、文件、接口和其他6大类20多种表引擎。每一种表引擎都有着各自的特点，用户可以根据实际业务场景的要求，选择合适的表引擎使用。</p><ul><li>4.多线程与分布式</li></ul><p>多线程处理就是通过线程级并行的方式实现了性能的提升，ClickHouse将数据划分为多个partition，每个partition再进一步划分为多个index granularity，然后通过多个CPU核心分别处理其中的一部分来实现并行数据处理。这种设计下，可以使得ClickHouse单条Query就能利用整机所有CPU，极致的并行处理能力，极大的降低了查询延时。</p><p>分布式数据属于基于分而治之的基本思想，实现的优化，如果一台服务器性能吃紧，那么就利用多台服务的资源协同处理。这个前提是需要在数据层面实现数据的分布式，因为计算移动比数据移动更加划算，在各服务器之间，通过网络传输数据的成本是高昂的，所以预先将数据分布到各台服务器，将数据的计算查询直接下推到数据所在的服务器。</p><h2 id="index_granularity稀疏索引">index_granularity（稀疏索引）</h2><p><code>index_granularity = 8192</code>表示索引粒度为8192。在每个data part中，索引粒度参数的含义有二：</p><ul><li>每隔index_granularity行对主键组的数据进行采样，形成稀疏索引，并存储在primary.idx文件中；</li><li>每隔index_granularity行对每一列的压缩数据（[column].bin）进行采样，形成数据标记，并存储在[column].mrk文件中。</li></ul><p>index_granularity、primary.idx、[column].bin/mrk之间的关系可以用下面的简图来表示。</p><div> <img src="/images/article/0013-002.png" style="width:100%;"></div><p><br></p><ul><li>1.这个参数规定了数据按照索引规定排序以后，间隔多少行会建立一个索引的Marks，即索引值</li><li>2.稀疏索引的意义即是Clickhouse不对所有的列都建立索引（相比较Mysql的B树索引会为每行都建立），而是间隔index_granularity列才建立一个。</li><li>3.Marks与Marks number均被保存在内存中，利于查询的时候快速检索。</li></ul><p><strong><em>备注</em></strong>：</p><ul><li>虽然是稀疏索引，但是如果索引中的列过多，则根据索引来划分数据会更稀疏，建立的索引也需要更多，影响写入性能，也会增加内存的使用</li><li>相比普通的B树索引，稀疏索引需要的内存更少，但是可能导致需要扫描的行数比实际的多；查询命中第某个索引，则需要扫描{index_granularity}行的数据，但是其实内部(查询的数据只占了少部分，带来了无效扫描）</li><li>有2个列组合做组合索引，一个值比较稀疏、一个值比较集中，要选稀疏的值放在第一位。只能选择一个列做单索引，如果有2个备选的值，要选比较稀疏的。</li></ul><h2 id="常用sql语法">常用SQL语法</h2><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 列出数据库列表
show databases;

-- 列出数据库中表列表
show tables;

-- 创建数据库
create database test;

-- 删除一个表
drop table if exists test.t1;

-- 创建第一个表
create /*temporary*/ table /*if not exists*/ test.m1 (
 id UInt16
,name String
) ENGINE = Memory
;
-- 插入测试数据
insert into test.m1 (id, name) values (1, 'abc'), (2, 'bbbb');

-- 查询
select * from test.m1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="默认值">默认值</h3><blockquote><p>默认值 的处理方面, ClickHouse 中,默认值总是有的,如果没有显示式指定的话,会按字段类型处理：</p><p>数字类型, 0<br> 字符串,空字符串<br> 数组,空数组<br> 日期, 0000-00-00<br> 时间, 0000-00-00 00:00:00<br> 注：NULLs 是不支持的</p></blockquote><h3 id="数据类型">数据类型</h3><ul><li><code>1.</code>整型：UInt8,UInt16,UInt32,UInt64,Int8,Int16,Int32,Int64 范围U开头-2<sup>N/2~2</sup>N-1;非U开头0～2^N-1</li><li><code>2.</code>枚举类型：Enum8,Enum16 Enum(‘hello’=1,‘test’=-1),Enum是有符号的整型映射的,因此负数也是可以的</li><li><code>3.</code>字符串型：FixedString(N),String N是最大字节数,不是字符长度,如果是UTF8字符串,那么就会占3个字节,GBK会占2字节;String可以用来替换VARCHAR,BLOB,CLOB等数据类型</li><li><code>4.</code>时间类型：Date<br></li><li><code>5.</code>数组类型：Array(T) T是一个基本类型,包括arry在内,官方不建议使用多维数组</li><li><code>6.</code>元组：Tuple<br></li><li><code>7.</code>结构：Nested(name1 Type1,name2 Type2,…) 类似一种map的结</li></ul><h3 id="物化列">物化列</h3><blockquote><p>指定 MATERIALIZED 表达式,即将一个列作为<code>物化列</code>处理了,这意味着这个列的值不能从<code>insert</code> 语句获取,只能是自己计算出来的。<br> 同时,物化列也不会出现在 <code>select *</code> 的结果中：</p></blockquote><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">drop table if exists test.m2;
create table test.m2 (
 a MATERIALIZED (b+1)
,b UInt16
) ENGINE = Memory;
insert into test.m2 (b) values (1);
select * from test.m2;
select a, b from test.m2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="表达式列">表达式列</h3><blockquote><p>ALIAS 表达式列某方面跟物化列相同,就是它的值不能从 insert 语句获取。<br> 不同的是, 物化列 是会真正保存数据（这样查询时不需要再计算）,<br> 而表达式列不会保存数据（这样查询时总是需要计算）,只是在查询时返回表达式的结果。</p></blockquote><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create table test.m3 (a ALIAS (b+1), b UInt16) ENGINE = Memory;
insert into test.m3(b) values (1);
select * from test.m3;
select a, b from test.m3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="引擎engine">引擎/engine</h3><blockquote><p>引擎是clickhouse设计的精华部分</p></blockquote><h3 id="tinylog">TinyLog</h3><blockquote><p>最简单的一种引擎,每一列保存为一个文件,里面的内容是压缩过的,不支持索引<br> 这种引擎没有并发控制,所以,当你需要在读,又在写时,读会出错。并发写,内容都会坏掉。</p></blockquote><p><code>应用场景:</code></p><ul><li><ol type="a"><li>基本上就是那种只写一次</li></ol></li><li><ol start="2" type="a"><li>然后就是只读的场景。</li></ol></li><li><ol start="3" type="a"><li>不适用于处理量大的数据,官方推荐,使用这种引擎的表最多 100 万行的数据</li></ol></li></ul><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">drop table if exists test.tinylog;
create table test.tinylog (a UInt16, b UInt16) ENGINE = TinyLog;
insert into test.tinylog(a,b) values (7,13);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>此时<code>/var/lib/clickhouse/data/test/tinylog</code>保存数据的目录结构：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">├── a.bin
├── b.bin
└── sizes.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>a.bin</code> 和 <code>b.bin</code> 是压缩过的对应的列的数据, <code>sizes.json</code> 中记录了每个 <code>*.bin</code> 文件的大小</p><h3 id="log">Log</h3><blockquote><p>这种引擎跟 TinyLog 基本一致<br> 它的改进点,是加了一个 <code>__marks.mrk</code> 文件,里面记录了每个数据块的偏移<br> 这样做的一个用处,就是可以准确地切分读的范围,从而使用并发读取成为可能<br> 但是,它是不能支持并发写的,一个写操作会阻塞其它读写操作<br> Log 不支持索引,同时因为有一个 <code>__marks.mrk</code> 的冗余数据,所以在写入数据时,一旦出现问题,这个表就废了</p></blockquote><p><code>应用场景:</code></p><blockquote><p>同 TinyLog 差不多,它适用的场景也是那种写一次之后,后面就是只读的场景,临时数据用它保存也可以</p></blockquote><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">drop table if exists test.log;
create table test.log (a UInt16, b UInt16) ENGINE = Log;
insert into test.log(a,b) values (7,13);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>此时<code>/var/lib/clickhouse/data/test/log</code>保存数据的目录结构：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">├── __marks.mrk
├── a.bin
├── b.bin
└── sizes.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="memory">Memory</h3><blockquote><p>内存引擎,数据以未压缩的原始形式直接保存在内存当中,服务器重启数据就会消失<br> 可以并行读,读写互斥锁的时间也非常短<br> 不支持索引,简单查询下有非常非常高的性能表现</p></blockquote><p><code>应用场景:</code></p><ul><li><ol type="a"><li>进行测试</li></ol></li><li><ol start="2" type="a"><li>在需要非常高的性能,同时数据量又不太大（上限大概 1 亿行）的场景</li></ol></li></ul><h3 id="merge">Merge</h3><blockquote><p>一个工具引擎,本身不保存数据,只用于把指定库中的指定多个表链在一起。<br> 这样,读取操作可以并发执行,同时也可以利用原表的索引,但是,此引擎不支持写操作<br> 指定引擎的同时,需要指定要链接的库及表,库名可以使用一个表达式,表名可以使用正则表达式指定</p></blockquote><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create table test.tinylog1 (id UInt16, name String) ENGINE=TinyLog;
create table test.tinylog2 (id UInt16, name String) ENGINE=TinyLog;
create table test.tinylog3 (id UInt16, name String) ENGINE=TinyLog;

insert into test.tinylog1(id, name) values (1, 'tinylog1');
insert into test.tinylog2(id, name) values (2, 'tinylog2');
insert into test.tinylog3(id, name) values (3, 'tinylog3');

use test;
create table test.merge (id UInt16, name String) 
  ENGINE=Merge(currentDatabase(), '^tinylog[0-9]+');

select _table,* from test.merge order by id desc

┌─_table───┬─id─┬─name─────┐
│ tinylog3 │  3 │ tinylog3 │
│ tinylog2 │  2 │ tinylog2 │
│ tinylog1 │  1 │ tinylog1 │
└──────────┴────┴──────────┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>注：</code>_table 这个列,是因为使用了Merge多出来的一个的一个虚拟列 &gt; a. 它表示原始数据的来源表,它不会出现在 <code>show table</code> 的结果当中<br> &gt; b. <code>select *</code> 不会包含它</p><h3 id="distributed">Distributed</h3><blockquote><p>与 Merge 类似, Distributed 也是通过一个逻辑表,去访问各个物理表,设置引擎时的样子是：</p></blockquote><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">Distributed(remote_group, database, table [, sharding_key])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>其中：<br> <code>remote_group</code> /etc/clickhouse-server/config.xml中remote_servers参数<br> <code>database</code> 是各服务器中的库名<br> <code>table</code> 是表名<br> <code>sharding_key</code> 是一个寻址表达式,可以是一个列名,也可以是像 rand() 之类的函数调用,<br> 它与 remote_servers 中的 weight 共同作用,决定在 写 时往哪个 shard 写</p></blockquote><blockquote><p>配置文件中的 <code>remote_servers</code></p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>remote_servers</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>log</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shard</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>weight</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>weight</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>internal_replication</span><span class="token punctuation">&gt;</span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>internal_replication</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>replica</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>host</span><span class="token punctuation">&gt;</span></span>172.17.0.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>host</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>port</span><span class="token punctuation">&gt;</span></span>9000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>port</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>replica</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shard</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shard</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>weight</span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>weight</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>internal_replication</span><span class="token punctuation">&gt;</span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>internal_replication</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>replica</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>host</span><span class="token punctuation">&gt;</span></span>172.17.0.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>host</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>port</span><span class="token punctuation">&gt;</span></span>9000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>port</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>replica</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shard</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>log</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>remote_servers</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>log</code> 是某个 shard 组的名字,就是上面的 remote_group 的值</li><li><code>shard</code> 是固定标签</li><li><code>weight</code> 是权重,前面说的 sharding_key 与这个有关。</li></ul><pre class="line-numbers language-none"><code class="language-none">简单来说,上面的配置,理论上来看: 
第一个 shard "被选中"的概率是 `1 / (1 + 2)` ,第二个是 `2 / (1 + 2)` 这很容易理解。
但是,sharding_key 的工作情况,是按实际数字的"命中区间"算的,即第一个的区间是 `[0, 1)` 的周期,第二个区间是`[1, 1+2)`的周期。
比如把 sharding_key 设置成id,当id=0或id=3时,一定是写入到第一个 shard 中,
如果把`sharding_key`设置成`rand()` ,那系统会对应地自己作一般化转换吧,这种时候就是一种概率场景了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>internal_replication</code> 是定义针对多个 replica 时的写入行为的。</li></ul><pre class="line-numbers language-none"><code class="language-none">如果为 false ,则会往所有的 replica 中写入数据,但是并不保证数据写入的一致性,所以这种情况时间一长,各 replica 的数据很可能出现差异。
如果为 true ,则只会往第一个可写的 replica 中写入数据（剩下的事"物理表"自己处理）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>replica</code> 就是定义各个冗余副本的,选项有 host , port , user , password 等</li></ul><blockquote><p>看一个实际的例子,我们先在两台机器上创建好物理表并插入一些测试数据：</p></blockquote><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create table test.tinylog_d1(id UInt16, name String) ENGINE=TinyLog;
insert into test.tinylog_d1(id, name) values (1, 'Distributed record 1');
insert into test.tinylog_d1(id, name) values (2, 'Distributed record 2');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在其中一台创建逻辑表：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create table test.tinylog_d (id UInt16, name String) 
  ENGINE=Distributed(log, test,tinylog_d1 , id);

-- 插入数据到逻辑表,观察数据分发情况
insert into test.tinylog_d(id, name) values (0, 'main');
insert into test.tinylog_d(id, name) values (1, 'main');
insert into test.tinylog_d(id, name) values (2, 'main');

select name,sum(id),count(id) from test.tinylog_d group by name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>注：</code>逻辑表中的写入操作是异步的,会先缓存在本机的文件系统上,并且,对于物理表的不可访问状态,并没有严格控制,所以写入失败丢数据的情况是可能发生的</p></blockquote><h3 id="null">Null</h3><blockquote><p>空引擎,写入的任何数据都会被忽略,读取的结果一定是空。</p></blockquote><blockquote><p>但是注意,虽然数据本身不会被存储,但是结构上的和数据格式上的约束还是跟普通表一样是存在的,同时,你也可以在这个引擎上创建视图</p></blockquote><h3 id="buffer">Buffer</h3><ul><li><code>1.</code>Buffer 引擎,像是Memory 存储的一个上层应用似的（磁盘上也是没有相应目录的）</li><li><code>2.</code>它的行为是一个缓冲区,写入的数据先被放在缓冲区,达到一个阈值后,这些数据会自动被写到指定的另一个表中</li><li><code>3.</code>和Memory 一样,有很多的限制,比如没有索引</li><li><code>4.</code>Buffer 是接在其它表前面的一层,对它的读操作,也会自动应用到后面表,<br> 但是因为前面说到的限制的原因,一般我们读数据,就直接从源表读就好了,缓冲区的这点数据延迟,只要配置得当,影响不大的</li><li><code>5.</code>Buffer 后面也可以不接任何表,这样的话,当数据达到阈值,就会被丢弃掉</li></ul><blockquote><p>一些特点：</p></blockquote><ul><li>如果一次写入的数据太大或太多,超过了 max 条件,则会直接写入源表。</li><li>删源表或改源表的时候,建议 Buffer 表删了重建。</li><li>“友好重启”时, Buffer 数据会先落到源表,“暴力重启”, Buffer 表中的数据会丢失。</li><li>即使使用了 Buffer ,多次的小数据写入,对比一次大数据写入,也 慢得多 （几千行与百万行的差距）</li></ul><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 创建源表
create table test.mergetree (sdt  Date, id UInt16, name String, point UInt16) ENGINE=MergeTree(sdt, (id, name), 10);
-- 创建 Buffer表
-- Buffer(database, table, num_layers, min_time, max_time, min_rows, max_rows, min_bytes, max_bytes)
create table test.mergetree_buffer as test.mergetree ENGINE=Buffer(test, mergetree, 16, 3, 20, 2, 10, 1, 10000);

insert into test.mergetree (sdt, id, name, point) values ('2017-07-10', 1, 'a', 20);
insert into test.mergetree_buffer (sdt, id, name, point) values ('2017-07-10', 1, 'b', 10);
select * from test.mergetree;
select '--';
select * from test.mergetree_buffer;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>database</code> 数据库<br> <code>table</code> 源表,这里除了字符串常量,也可以使用变量的。<br> <code>num_layers</code> 是类似”分区”的概念,每个分区的后面的 min / max 是独立计算的,官方推荐的值是 16 。<br> <code>min / max</code> 这组配置荐,就是设置阈值的,分别是 时间（秒）,行数,空间（字节）。<br> <code>阈值的规则:</code> 是”所有的 min 条件都满足, 或 至少一个 max 条件满足”。</p></blockquote><p>如果按上面我们的建表来说,所有的 min 条件就是：过了 3秒,2条数据,1 Byte。一个 max 条件是：20秒,或 10 条数据,或有 10K</p><h3 id="set">Set</h3><p>Set 这个引擎有点特殊,因为它只用在 IN 操作符右侧,你不能对它 select</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create table test.set(id UInt16, name String) ENGINE=Set;
insert into test.set(id, name) values (1, 'hello');
-- select 1 where (1, 'hello') in test.set; -- 默认UInt8 需要手动进行类型转换
select 1 where (toUInt16(1), 'hello') in test.set;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>注:</code> Set 引擎表,是全内存运行的,但是相关数据会落到磁盘上保存,启动时会加载到内存中。所以,意外中断或暴力重启,是可能产生数据丢失问题的</p></blockquote><h3 id="join">Join</h3><p><code>TODO</code></p><h3 id="mergetree">MergeTree</h3><p>这个引擎是 ClickHouse 的<code>重头戏</code>,它支持<code>一个日期和一组主键的两层式索引</code>,还可以<code>实时更新数据</code>。同时,索引的粒度可以自定义,外加直接支持采样功能</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">MergeTree(EventDate, (CounterID, EventDate), 8192)
MergeTree(EventDate, intHash32(UserID), (CounterID, EventDate, intHash32(UserID)), 8192)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>EventDate</code> 一个日期的列名 <code>intHash32(UserID)</code> 采样表达式 <code>(CounterID, EventDate)</code> 主键组（里面除了列名,也支持表达式）,也可以是一个表达式 <code>8192</code> 主键索引的粒度</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">drop table if exists test.mergetree1;
create table test.mergetree1 (sdt  Date, id UInt16, name String, cnt UInt16) ENGINE=MergeTree(sdt, (id, name), 10);

-- 日期的格式,好像必须是 yyyy-mm-dd
insert into test.mergetree1(sdt, id, name, cnt) values ('2018-06-01', 1, 'aaa', 10);
insert into test.mergetree1(sdt, id, name, cnt) values ('2018-06-02', 4, 'bbb', 10);
insert into test.mergetree1(sdt, id, name, cnt) values ('2018-06-03', 5, 'ccc', 11);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时<code>/var/lib/clickhouse/data/test/mergetree1</code>的目录结构：</p><pre class="line-numbers language-none"><code class="language-none">├── 20180601_20180601_1_1_0
│   ├── checksums.txt
│   ├── columns.txt
│   ├── id.bin
│   ├── id.mrk
│   ├── name.bin
│   ├── name.mrk
│   ├── cnt.bin
│   ├── cnt.mrk 
│   ├── cnt.idx
│   ├── primary.idx
│   ├── sdt.bin
│   └── sdt.mrk -- 保存一下块偏移量
├── 20180602_20180602_2_2_0
│   └── ...
├── 20180603_20180603_3_3_0
│   └── ...
├── format_version.txt
└── detached<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="replacingmergetree">ReplacingMergeTree</h3><ul><li><code>1</code>.在 MergeTree 的基础上,添加了”处理重复数据”的功能=&gt;实时数据场景</li><li><code>2</code>.相比 MergeTree ,ReplacingMergeTree 在最后加一个”版本列”,它跟时间列配合一起,用以区分哪条数据是”新的”,<br> 并把旧的丢掉(这个过程是在 merge 时处理,不是数据写入时就处理了的,平时重复的数据还是保存着的,并且查也是跟平常一样会查出来的)</li><li><code>3</code>.主键列组用于区分重复的行</li></ul><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 版本列 允许的类型是, UInt 一族的整数,或 Date 或 DateTime
create table test.replacingmergetree (sdt  Date, id UInt16, name String, cnt UInt16) ENGINE=ReplacingMergeTree(sdt, (name), 10, cnt);

insert into test.replacingmergetree (sdt, id, name, cnt) values ('2018-06-10', 1, 'a', 20);
insert into test.replacingmergetree (sdt, id, name, cnt) values ('2018-06-10', 1, 'a', 30);
insert into test.replacingmergetree (sdt, id, name, cnt) values ('2018-06-11', 1, 'a', 20);
insert into test.replacingmergetree (sdt, id, name, cnt) values ('2018-06-11', 1, 'a', 30);
insert into test.replacingmergetree (sdt, id, name, cnt) values ('2018-06-11', 1, 'a', 10);

select * from test.replacingmergetree;

-- 如果记录未执行merge,可以手动触发一下 merge 行为
optimize table test.replacingmergetree;

┌────────sdt─┬─id─┬─name─┬─cnt─┐
│ 2018-06-11 │  1 │ a    │  30 │
└────────────┴────┴──────┴─────┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="summingmergetree">SummingMergeTree</h3><ul><li><code>1</code>.SummingMergeTree 就是在 merge 阶段把数据sum求和</li><li><code>2</code>.sum求和的列可以指定,不可加的未指定列,会取一个最先出现的值</li></ul><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create table test.summingmergetree (sdt Date, name String, a UInt16, b UInt16) ENGINE=SummingMergeTree(sdt, (sdt, name), 8192, (a));

insert into test.summingmergetree (sdt, name, a, b) values ('2018-06-10', 'a', 1, 20);
insert into test.summingmergetree (sdt, name, a, b) values ('2018-06-10', 'b', 2, 11);
insert into test.summingmergetree (sdt, name, a, b) values ('2018-06-11', 'b', 3, 18);
insert into test.summingmergetree (sdt, name, a, b) values ('2018-06-11', 'b', 3, 82);
insert into test.summingmergetree (sdt, name, a, b) values ('2018-06-11', 'a', 3, 11);
insert into test.summingmergetree (sdt, name, a, b) values ('2018-06-12', 'c', 1, 35);

-- 手动触发一下 merge 行为
optimize table test.summingmergetree;

select * from test.summingmergetree;

┌────────sdt─┬─name─┬─a─┬──b─┐
│ 2018-06-10       │         a    │   1   │   20   │
│ 2018-06-10       │         b    │   2   │   11   │
│ 2018-06-11       │         a    │   3   │   11   │
│ 2018-06-11       │         b    │   6   │   18   │
│ 2018-06-12       │         c    │   1   │   35   │
└────────────┴──────┴───┴────┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>注:</code> 可加列不能是主键中的列,并且如果某行数据可加列都是 null ,则这行会被删除</p><h3 id="aggregatingmergetree">AggregatingMergeTree</h3><p>AggregatingMergeTree 是在 MergeTree 基础之上,针对聚合函数结果,作增量计算优化的一个设计,它会在 merge 时,针对主键预处理聚合的数据 应用于AggregatingMergeTree 上的聚合函数除了普通的 sum, uniq等,还有 sumState , uniqState ,及 sumMerge , uniqMerge 这两组</p><ul><li><code>1.</code>聚合数据的预计算</li></ul><p>是一种”空间换时间”的权衡,并且是以减少维度为代价的</p><p>假设原始有三个维度,一个需要 count 的指标</p><table><thead><tr><th>dim1</th><th>dim2</th><th>dim3</th><th style="text-align: center;">measure1</th></tr></thead><tbody><tr><td>aaaa</td><td>a</td><td>1</td><td style="text-align: center;">1</td></tr><tr><td>aaaa</td><td>b</td><td>2</td><td style="text-align: center;">1</td></tr><tr><td>bbbb</td><td>b</td><td>3</td><td style="text-align: center;">1</td></tr><tr><td>cccc</td><td>b</td><td>2</td><td style="text-align: center;">1</td></tr><tr><td>cccc</td><td>c</td><td>1</td><td style="text-align: center;">1</td></tr><tr><td>dddd</td><td>c</td><td>2</td><td style="text-align: center;">1</td></tr><tr><td>dddd</td><td>a</td><td>1</td><td style="text-align: center;">1</td></tr></tbody></table><p>通过减少一个维度的方式,来以 count 函数聚合一次 M</p><table><thead><tr><th>dim2</th><th>dim3</th><th style="text-align: center;">count(measure1)</th></tr></thead><tbody><tr><td>a</td><td>1</td><td style="text-align: center;">3</td></tr><tr><td>b</td><td>2</td><td style="text-align: center;">2</td></tr><tr><td>b</td><td>3</td><td style="text-align: center;">1</td></tr><tr><td>c</td><td>1</td><td style="text-align: center;">1</td></tr><tr><td>c</td><td>2</td><td style="text-align: center;">1</td></tr></tbody></table><ul><li><code>2.</code>聚合数据的增量计算</li></ul><p>对于 AggregatingMergeTree 引擎的表,不能使用普通的 INSERT 去添加数据,可以用：</p><ul><li><code>a.</code> INSERT SELECT 来插入数据</li><li><code>b.</code> 更常用的,是可以创建一个物化视图</li></ul><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">drop table if exists test.aggregatingmergetree;
create table test.aggregatingmergetree(
sdt Date
, dim1 String
, dim2 String
, dim3 String
, measure1 UInt64
) ENGINE=MergeTree(sdt, (sdt, dim1, dim2, dim3), 8192);

-- 创建一个物化视图,使用 AggregatingMergeTree
drop table if exists test.aggregatingmergetree_view;
create materialized view test.aggregatingmergetree_view
ENGINE = AggregatingMergeTree(sdt,(dim2, dim3), 8192)
as
select sdt,dim2, dim3, uniqState(dim1) as uv
from test.aggregatingmergetree
group by sdt,dim2, dim3;

insert into test.aggregatingmergetree (sdt, dim1, dim2, dim3, measure1) values ('2018-06-10', 'aaaa', 'a', '10', 1);
insert into test.aggregatingmergetree (sdt, dim1, dim2, dim3, measure1) values ('2018-06-10', 'aaaa', 'a', '10', 1);
insert into test.aggregatingmergetree (sdt, dim1, dim2, dim3, measure1) values ('2018-06-10', 'aaaa', 'b', '20', 1);
insert into test.aggregatingmergetree (sdt, dim1, dim2, dim3, measure1) values ('2018-06-10', 'bbbb', 'b', '30', 1);
insert into test.aggregatingmergetree (sdt, dim1, dim2, dim3, measure1) values ('2018-06-10', 'cccc', 'b', '20', 1);
insert into test.aggregatingmergetree (sdt, dim1, dim2, dim3, measure1) values ('2018-06-10', 'cccc', 'c', '10', 1);
insert into test.aggregatingmergetree (sdt, dim1, dim2, dim3, measure1) values ('2018-06-10', 'dddd', 'c', '20', 1);
insert into test.aggregatingmergetree (sdt, dim1, dim2, dim3, measure1) values ('2018-06-10', 'dddd', 'a', '10', 1);

-- 按 dim2 和 dim3 聚合 count(measure1)
select dim2, dim3, count(measure1) from test.aggregatingmergetree group by dim2, dim3;

-- 按 dim2 聚合 UV
select dim2, uniq(dim1) from test.aggregatingmergetree group by dim2;

-- 手动触发merge
OPTIMIZE TABLE test.aggregatingmergetree_view;
select * from test.aggregatingmergetree_view;

-- 查 dim2 的 uv
select dim2, uniqMerge(uv) from test.aggregatingmergetree_view group by dim2 order by dim2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="collapsingmergetree">CollapsingMergeTree</h3><blockquote><p>是专门为 OLAP 场景下,一种”变通”存数做法而设计的,在数据是不能改,更不能删的前提下,通过”运算”的方式,去抹掉旧数据的影响,把旧数据”减”去即可,从而解决”最终状态”类的问题,比如 <code>当前有多少人在线？</code></p></blockquote><blockquote><p>“以加代删”的增量存储方式,带来了聚合计算方便的好处,代价却是存储空间的翻倍,并且,对于只关心最新状态的场景,中间数据都是无用的</p></blockquote><blockquote><p>CollapsingMergeTree 在创建时与 MergeTree 基本一样,除了最后多了一个参数,需要指定 Sign 位（必须是 Int8 类型）</p></blockquote><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create table test.collapsingmergetree(sign Int8, sdt Date, name String, cnt UInt16) ENGINE=CollapsingMergeTree(sdt, (sdt, name), 8192, sign);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><hr/><div class="reprint" id="reprint-statement"><div class="reprint__author"> <span class="reprint-meta" style="font-weight: bold;"><i class="fas fa-user">文章作者:</i></span> <span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">darebeat</a></span></div><div class="reprint__type"> <span class="reprint-meta" style="font-weight: bold;"><i class="fas fa-link">文章链接:</i></span> <span class="reprint-info"><a href="https://www.darebeat.cn/article/13/">https://www.darebeat.cn/article/13/</a></span></div><div class="reprint__notice"> <span class="reprint-meta" style="font-weight: bold;"><i class="fas fa-copyright">版权声明:</i></span> <span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">darebeat</a> !</span></div></div><script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML});
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script><div class="tag_share" style="display: block;"><div class="post-meta__tag-list" style="display: inline-block;"><div class="article-tag"> <a href="/tags/database/"><span class="chip bg-color">database</span></a> <a href="/tags/clickhouse/"><span class="chip bg-color">clickhouse</span></a> <a href="/tags/olap/"><span class="chip bg-color">olap</span></a></div></div><div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div><style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style><div id="reward"> <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fas fa-times"></i></a><h4 class="reward-title">你的赞赏是我前进的动力！</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"> <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"> <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>
    $(function () {
        $('.tabs').tabs();
    });
</script></div></div><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i> &nbsp;上一篇</div><div class="card"><a href="/article/34/"><div class="card-image"> <img src="/images/card/0034.jpg" class="responsive-img" alt="一文带你轻松了解SSH命令"> <span class="card-title">一文带你轻松了解SSH命令</span></div></a><div class="card-content article-content"><div class="summary block-with-text"> OpenSSH是SSH连接工具的免费版本。telnet，rlogin和ftp用户可能还没意识到他们在互联网上传输的密码是未加密的，但SSH是加密的，OpenSSH加密所有通信（包括密码），有效消除了窃听，连接劫持和其它攻击。</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2020-12-04</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/shell/" class="post-category">shell</a></span></div></div><div class="card-action article-tags"> <a href="/tags/ssh/"><span class="chip bg-color">ssh</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color"> 下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/article/33/"><div class="card-image"> <img src="/images/card/0033.jpg" class="responsive-img" alt="算法的时间与空间复杂度"> <span class="card-title">算法的时间与空间复杂度</span></div></a><div class="card-content article-content"><div class="summary block-with-text"> 从算法所占用的「时间」和「空间」两个维度去考量不同算法之间的优劣。</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2020-12-03</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/algorithm/" class="post-category">algorithm</a></span></div></div><div class="card-action article-tags"> <a href="/tags/algorithm/"><span class="chip bg-color">algorithm</span></a> <a href="/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"><span class="chip bg-color">时间复杂度</span></a> <a href="/tags/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"><span class="chip bg-color">空间复杂度</span></a></div></div></div></div></article></div><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card" style="background-color: white;"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        /* modify the toc link href to support Chinese. */
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        /* modify the heading title id to support Chinese. */
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        /* Set scroll toc fixed. */
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        /* 切换TOC目录展开收缩的相关操作. */
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script></main><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom: 15px !important;"><div class="col s12 m8 l8 copy-right"> Copyright&nbsp;&copy; <span id="year">2019-2025</span> &nbsp;|&nbsp;&nbsp;Powered&nbsp;by&nbsp; <a href="/about" target="_blank">darebeat</a><br> <span id="busuanzi_container_site_pv" style='display:none'>|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次</span> <span id="busuanzi_container_site_uv" style='display:none'>|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br> <span id="sitetime">载入运行时间...</span><script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "5";
                    var startDate = "17";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script><br></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/darebeat" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i></a><a href="mailto:darebeat@126.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i></a><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=871731559" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 871731559" data-position="top" data-delay="50"><i class="fab fa-qq"></i></a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><script>
    $(document).ready(function () {
        /* 50ms周期检测函数 */
        var int = setInterval(fixCount, 50);
        /* 初始化首次数据 */
        var pvcountOffset = 20000;
        var uvcountOffset = 5000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                /* 加上初始数据 */
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset);
                /* 停止检测 */
                clearInterval(int);
            }
        }
    });
</script><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i> &nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" value="" placeholder="请输入搜索的关键字，比如:bigdata" class="search-input"></div><div id="searchResult"></div></div></div><script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                /* get the contents from search data */
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    /* perform local searching */
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        /* only match artiles with not empty titles and contents */
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        /* show search results */
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim(); /* .replace(/<[^>]+>/g, ""); */
                            if (first_occur >= 0) {
                                /* cut out 100 characters */
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                /* highlight all keywords */
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>";
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.min.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script><script src="/libs/others/clicklove.min.js" async="async"></script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script src="/libs/instantpage/instantpage.min.js" type="module"></script></body></html>